#
# Dependencies Required to Develop `pycommons`
#
# In this file we list all the libraries that are required to develop
# `pycommons` code. This means that you want to run the complete `make`
# process, including all the unit tests, the static analysis, and building the
# documentation. Notice that none of this is necessary if you just want to use
# `pycommons` or even just want to implement an algorithm or problem for your
# own purposes. Only if you want to do all the checks and the whole build
# process, maybe because you want to submit code to the `pycommons` project,
# then you need all of these dependencies. For only using `pycommons`, it is
# sufficient to load the dependencies specified in `requirements.txt`.
# Nevertheless, I think even then it may still be a good idea to use the full
# `make` process, because the static analysis and unit tests are, indeed,
# useful. They enforce a uniform coding style, help you to find bugs, and kind
# of push you to use best practices. I personally learned a lot from the
# static analysis and the unit tests indeed revealed errors.
#
# For developing or contributing to `pycommons`, you should install the
# dependencies below. You can do this via
# `pip install --no-input --timeout 360 --retries 100 -r requirements-dev.txt`
# with a text file `requirements-dev.txt` that has the exact same contents as
# this file here.
#
# `pycommons` is available at https://thomasweise.github.io/pycommons.
# This file is available at https://github.com/thomasWeise/pycommons.
#
# Below, we list each library required for development and specify the reason
# why it is needed. Notice that these libraries may, in turn, depend on other
# libraries. We cannot maintain a full list of these recursive dependencies.
# Here we only list the top-level dependencies that are actually used in the
# `pycommons` build process.
#

# We need pytest to run the unit tests.
# Unit tests test components of our package, e.g., functions or objects, and
# compare their behavior with the expected behaviors in some test cases.
# This helps spotting errors where code behaves differently from the
# expectation. Of course, unit tests cannot guarantee that there are no
# errors. But they can at least check whether our code behaves as it should in
# some usual or border cases. Also, they can help us find out if changes in
# the code lead to changes in (tested/expected) behavior.
pytest == 7.4.3

# setuptools, testresources, twine, virtualenv, and wheel are needed for
# generating the installable pip package.
setuptools == 68.2.2
testresources == 2.0.1
twine == 4.0.2
virtualenv == 20.24.6
wheel == 0.41.2

# sphinx is needed for generating the documentation. Together with its
# modules, it parses the documentation root file as well as the code and
# generates the html files with the documentation. It therefore uses the
# docstrings and the type hints.
sphinx == 7.2.6
sphinx-autodoc-typehints == 1.24.0
# myst-parser is needed for including README.md into the documentation
myst-parser == 2.0.0

# yaml is used only in tests and examples.
pyyaml == 6.0.1

# minify_html is needed to minify html output. Our documentation is fairly
# large. We apply this tool to try to reduce the file size of the
# documentation, by, e.g., removing useless white space.
minify_html == 0.11.1

# for converting the additional markdown files to HTML
markdown == 3.5
