<!doctype html><html data-content_root=../../../ lang=en><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0"name=viewport><title>pycommons.io.parser — pycommons 0.8.89 documentation</title><link href="../../../_static/pygments.css?v=b86133f3"rel=stylesheet><link href="../../../_static/bizstyle.css?v=5283bb3d"rel=stylesheet><script src="../../../_static/documentation_options.js?v=4db5eb0a"></script><script src="../../../_static/doctools.js?v=fd6eb6e6"></script><script src="../../../_static/sphinx_highlight.js?v=6ffebe34"></script><script src=../../../_static/bizstyle.js></script><link href=https://thomasweise.github.io/pycommons/_modules/pycommons/io/parser.html rel=canonical><link href=../../../genindex.html rel=index title=Index><link href=../../../search.html rel=search title=Search><meta content="width=device-width,initial-scale=1.0"name=viewport><body><div aria-label=Related class=related role=navigation><h3>Navigation</h3><ul><li class=right style=margin-right:10px><a title="General Index"accesskey=I href=../../../genindex.html>index</a><li class=right><a title="Python Module Index"href=../../../py-modindex.html>modules</a> |<li class="nav-item nav-item-0"><a href=../../../index.html>pycommons 0.8.89 documentation</a> »<li class="nav-item nav-item-1"><a accesskey=U href=../../index.html>Module code</a> »<li class="nav-item nav-item-this"><a href>pycommons.io.parser</a></ul></div><div class=document><div class=documentwrapper><div class=bodywrapper><div class=body role=main><h1>Source code for pycommons.io.parser</h1><div class=highlight><pre>
<span></span><span class=sd>"""</span>
<span class=sd>A tool for recursively parsing data from directories.</span>

<span class=sd>This module provides a unified API for parsing data from files in</span>
<span class=sd>directories. The goal is to offer a way to return a generator that</span>
<span class=sd>allows us to iterate over the data loaded. While we iterate over this</span>
<span class=sd>data, the generator internally iterates over the files.</span>

<span class=sd>This means that the control of how the data is loaded stays with the user,</span>
<span class=sd>while the programmer can implement the necessary methods to load and process</span>
<span class=sd>data in a natural way.</span>
<span class=sd>"""</span>

<span class=kn>from</span><span class=w> </span><span class=nn>typing</span><span class=w> </span><span class=kn>import</span> <span class=n>Final</span><span class=p>,</span> <span class=n>Generator</span><span class=p>,</span> <span class=n>Iterable</span><span class=p>,</span> <span class=n>TypeVar</span>

<span class=kn>from</span><span class=w> </span><span class=nn>pycommons.io.console</span><span class=w> </span><span class=kn>import</span> <span class=n>logger</span>
<span class=kn>from</span><span class=w> </span><span class=nn>pycommons.io.path</span><span class=w> </span><span class=kn>import</span> <span class=n>Path</span><span class=p>,</span> <span class=n>directory_path</span><span class=p>,</span> <span class=n>file_path</span>
<span class=kn>from</span><span class=w> </span><span class=nn>pycommons.types</span><span class=w> </span><span class=kn>import</span> <span class=n>type_error</span>

<span class=c1>#: the type variable for data to be read from the directories</span>
<span class=n>T</span> <span class=o>=</span> <span class=n>TypeVar</span><span class=p>(</span><span class=s2>"T"</span><span class=p>)</span>


<div class=viewcode-block id=Parser>
<a class=viewcode-back href=../../../pycommons.io.html#pycommons.io.parser.Parser>[docs]</a>
<span class=k>class</span><span class=w> </span><span class=nc>Parser</span><span class=p>[</span><span class=n>T</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    The parser class.</span>

<span class=sd>    This class allows you to implement convenient parsing routines that can</span>
<span class=sd>    hierarchically process nested directories of files and return a stream,</span>
<span class=sd>    i.e., a :class:`Generator` of results. In other words, it flattens the</span>
<span class=sd>    hierarchical processing of directories into a linear sequence of data.</span>
<span class=sd>    This allows the user of the API stay in control of when the data is loaded</span>
<span class=sd>    while the programmer of the parser API can work in a convenient way with</span>
<span class=sd>    high-level abstractions. Another advantage of this parsing API is that its</span>
<span class=sd>    results can be processed like a stream and be piped into some filters,</span>
<span class=sd>    processors, or even output destinations while it is loaded from the files.</span>
<span class=sd>    For example, we can extract certain elements of data from huge collections</span>
<span class=sd>    of files and while they are loaded, they could already be processed and</span>
<span class=sd>    stored to a stream of CSV data.</span>

<span class=sd>    The method :meth:`~pycommons.io.parser.Parser.parse` can be applied to any</span>
<span class=sd>    path to a file or directory and will hierarchically process the path and</span>
<span class=sd>    yield the parsing results one by one. This is the normal entry point</span>
<span class=sd>    function for this parsing API.</span>
<span class=sd>    The method :meth:`~pycommons.io.parser.Parser.parse_file` is a convenient</span>
<span class=sd>    wrapper that processes a single file in *exactly the same way*.</span>
<span class=sd>    The method :meth:`~pycommons.io.parser.Parser.parse_directory` parses a</span>
<span class=sd>    path that identifies a directory.</span>

<span class=sd>    This class offers an internal API, where the internal functions are</span>
<span class=sd>    prefixed with `_`, that allows you to customize the hierarchical parsing</span>
<span class=sd>    process to a high degree. You can decide which directories and files to</span>
<span class=sd>    process, and you can set up and tear down datastructures on a per-file or</span>
<span class=sd>    per-directory basis. All the internal functions are invoked in a</span>
<span class=sd>    consistent way, regardless whether you parse single files or nested</span>
<span class=sd>    directories.</span>
<span class=sd>    """</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_start_parse</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>root</span><span class=p>:</span> <span class=n>Path</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
<span class=w>        </span><span class=sd>"""</span>
<span class=sd>        Begin the parsing process.</span>

<span class=sd>        This method is called before the recursing parsing begins. It can be</span>
<span class=sd>        used to initialize any internal datastructures to make the parser</span>
<span class=sd>        reusable.</span>

<span class=sd>        :param root: the root path of the parsing process</span>
<span class=sd>        """</span>

    <span class=c1># pylint: disable=W0613</span>
    <span class=k>def</span><span class=w> </span><span class=nf>_should_parse_file</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>file</span><span class=p>:</span> <span class=n>Path</span><span class=p>)</span> <span class=o>-></span> <span class=nb>bool</span><span class=p>:</span>  <span class=c1># noqa: ARG002</span>
<span class=w>        </span><span class=sd>"""</span>
<span class=sd>        Check whether we should start parsing a file.</span>

<span class=sd>        The other file-parsing routines are only called if this method returns</span>
<span class=sd>        `True` for a file. Any overriding method should first call the super</span>
<span class=sd>        method.</span>

<span class=sd>        :param file: the current file path</span>
<span class=sd>        :returns: `True` if the file should be parsed, `False` otherwise</span>
<span class=sd>        """</span>
        <span class=k>return</span> <span class=kc>True</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_start_parse_file</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>file</span><span class=p>:</span> <span class=n>Path</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
<span class=w>        </span><span class=sd>"""</span>
<span class=sd>        Check whether we should start parsing a file.</span>

<span class=sd>        Any method overriding this method should first invoke the super method</span>
<span class=sd>        and then perform its own startup code.</span>

<span class=sd>        :param file: the current file path</span>
<span class=sd>        """</span>

    <span class=c1># pylint: disable=W0613</span>
    <span class=k>def</span><span class=w> </span><span class=nf>_parse_file</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>file</span><span class=p>:</span> <span class=n>Path</span><span class=p>)</span> <span class=o>-></span> <span class=n>T</span> <span class=o>|</span> <span class=kc>None</span><span class=p>:</span>  <span class=c1># noqa: ARG002</span>
<span class=w>        </span><span class=sd>"""</span>
<span class=sd>        Parse a file and return the result.</span>

<span class=sd>        :param file: the current file path</span>
<span class=sd>        :returns: the parsing result</span>
<span class=sd>        """</span>
        <span class=k>return</span> <span class=kc>None</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_end_parse_file</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>file</span><span class=p>:</span> <span class=n>Path</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
<span class=w>        </span><span class=sd>"""</span>
<span class=sd>        Cleanup after a file has been parsed.</span>

<span class=sd>        Any method overriding this function should first perform its own</span>
<span class=sd>        cleanup and then call the super implementation.</span>

<span class=sd>        :param file: the current file path</span>
<span class=sd>        """</span>

    <span class=c1># pylint: disable=W0613</span>
    <span class=k>def</span><span class=w> </span><span class=nf>_should_list_directory</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>directory</span><span class=p>:</span> <span class=n>Path</span><span class=p>)</span> \
            <span class=o>-></span> <span class=nb>tuple</span><span class=p>[</span><span class=nb>bool</span><span class=p>,</span> <span class=nb>bool</span><span class=p>]:</span>  <span class=c1># noqa: ARG002</span>
<span class=w>        </span><span class=sd>"""</span>
<span class=sd>        Check whether we should parse a directory.</span>

<span class=sd>        This method is called whenever the parser enters a directory.</span>
<span class=sd>        It should return a :class:`tuple` of two :class:`bool` values.</span>
<span class=sd>        The first one indicates whether the sub-directories of this directory</span>
<span class=sd>        should be processed. `True` means that they are listed and processed.</span>
<span class=sd>        `False` means that they are skipped. The second Boolean value</span>
<span class=sd>        indicates whether the files inside the directory should be listed.</span>
<span class=sd>        `True` means that the files should be listed, `False` means that they</span>
<span class=sd>        are not.</span>

<span class=sd>        Any overriding method should first call the super method.</span>

<span class=sd>        :param directory: the current directory path</span>
<span class=sd>        :returns: A :class:`tuple` of two `bool` values, where the first one</span>
<span class=sd>            indicates whether sub-directories should be visited and the</span>
<span class=sd>            second one indicates whether files should be listed</span>
<span class=sd>        """</span>
        <span class=k>return</span> <span class=kc>True</span><span class=p>,</span> <span class=kc>True</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_start_list_directory</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>directory</span><span class=p>:</span> <span class=n>Path</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
<span class=w>        </span><span class=sd>"""</span>
<span class=sd>        Prepare for listing a directory.</span>

<span class=sd>        This method is only called if `_should_list_directory` returned</span>
<span class=sd>        `True`.</span>

<span class=sd>        :param directory: the current directory path</span>
<span class=sd>        """</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_end_list_directory</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>directory</span><span class=p>:</span> <span class=n>Path</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
<span class=w>        </span><span class=sd>"""</span>
<span class=sd>        Clean up after a directory has been processed.</span>

<span class=sd>        :param directory: the current directory path</span>
<span class=sd>        """</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_end_parse</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>root</span><span class=p>:</span> <span class=n>Path</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
<span class=w>        </span><span class=sd>"""</span>
<span class=sd>        End the parsing process.</span>

<span class=sd>        This method can perform any cleanup and purging of internal</span>
<span class=sd>        datastructures to make the parser reusable.</span>

<span class=sd>        :param root: the root path of the parsing process</span>
<span class=sd>        """</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_progress_logger</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>text</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
<span class=w>        </span><span class=sd>"""</span>
<span class=sd>        Log the progress.</span>

<span class=sd>        This method is called with a string that should be logged. By default,</span>
<span class=sd>        it forwards the string to :func:`logger`.</span>

<span class=sd>        :param text: the test</span>
<span class=sd>        """</span>
        <span class=n>logger</span><span class=p>(</span><span class=n>text</span><span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=nf>__internal_parse</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>paths</span><span class=p>:</span> <span class=n>Iterable</span><span class=p>[</span><span class=n>Path</span><span class=p>],</span> <span class=n>log_progress</span><span class=p>:</span> <span class=nb>bool</span><span class=p>,</span>
                         <span class=n>is_root</span><span class=p>:</span> <span class=nb>bool</span><span class=p>)</span> \
            <span class=o>-></span> <span class=n>Generator</span><span class=p>[</span><span class=n>T</span><span class=p>,</span> <span class=kc>None</span><span class=p>,</span> <span class=kc>None</span><span class=p>]:</span>
<span class=w>        </span><span class=sd>"""</span>
<span class=sd>        Perform the internal parsing work.</span>

<span class=sd>        This method should never be called directly. It is called by `parse`.</span>

<span class=sd>        :param paths: the paths to parse.</span>
<span class=sd>        :param log_progress: should we log progress?</span>
<span class=sd>        :param is_root: is this the root of parsing</span>
<span class=sd>        :returns: the generator</span>
<span class=sd>        """</span>
        <span class=n>current</span><span class=p>:</span> <span class=n>Path</span> <span class=o>|</span> <span class=kc>None</span> <span class=o>=</span> <span class=kc>None</span>
        <span class=k>for</span> <span class=n>current</span> <span class=ow>in</span> <span class=n>paths</span><span class=p>:</span>
            <span class=k>if</span> <span class=n>current</span><span class=o>.</span><span class=n>is_file</span><span class=p>():</span>
                <span class=c1># The current path identifies a file. We need to check whether</span>
                <span class=c1># this file should be parsed and, if so, parse it and yield</span>
                <span class=c1># from the parsing results.</span>
                <span class=n>should</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_should_parse_file</span><span class=p>(</span><span class=n>current</span><span class=p>)</span>
                <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>should</span><span class=p>,</span> <span class=nb>bool</span><span class=p>):</span>  <span class=c1># type check</span>
                    <span class=k>raise</span> <span class=n>type_error</span><span class=p>(</span><span class=n>should</span><span class=p>,</span> <span class=s2>"should"</span><span class=p>,</span> <span class=nb>bool</span><span class=p>)</span>
                <span class=k>if</span> <span class=n>should</span><span class=p>:</span>  <span class=c1># OK, the file should be parsed.</span>
                    <span class=bp>self</span><span class=o>.</span><span class=n>_start_parse_file</span><span class=p>(</span><span class=n>current</span><span class=p>)</span>
                    <span class=n>result</span><span class=p>:</span> <span class=n>T</span> <span class=o>|</span> <span class=kc>None</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_parse_file</span><span class=p>(</span><span class=n>current</span><span class=p>)</span>
                    <span class=k>if</span> <span class=n>result</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>  <span class=c1># We got some result.</span>
                        <span class=k>yield</span> <span class=n>result</span>
                    <span class=c1># Notify the end of parsing.</span>
                    <span class=bp>self</span><span class=o>.</span><span class=n>_end_parse_file</span><span class=p>(</span><span class=n>current</span><span class=p>)</span>
            <span class=k>elif</span> <span class=n>current</span><span class=o>.</span><span class=n>is_dir</span><span class=p>():</span>  <span class=c1># The path is a directory.</span>
                <span class=c1># Check if we should parse.</span>
                <span class=n>list_dirs</span><span class=p>,</span> <span class=n>list_files</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_should_list_directory</span><span class=p>(</span><span class=n>current</span><span class=p>)</span>
                <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>list_dirs</span><span class=p>,</span> <span class=nb>bool</span><span class=p>):</span>
                    <span class=k>raise</span> <span class=n>type_error</span><span class=p>(</span>  <span class=c1># wrong type</span>
                        <span class=n>list_dirs</span><span class=p>,</span> <span class=s2>"retval[1] of start_list_dir"</span><span class=p>,</span> <span class=nb>bool</span><span class=p>)</span>
                <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>list_files</span><span class=p>,</span> <span class=nb>bool</span><span class=p>):</span>
                    <span class=k>raise</span> <span class=n>type_error</span><span class=p>(</span>  <span class=c1># wrong type</span>
                        <span class=n>list_files</span><span class=p>,</span> <span class=s2>"retval[2] of start_list_dir"</span><span class=p>,</span> <span class=nb>bool</span><span class=p>)</span>
                <span class=k>if</span> <span class=n>list_dirs</span> <span class=ow>or</span> <span class=n>list_files</span><span class=p>:</span>
                    <span class=bp>self</span><span class=o>.</span><span class=n>_start_list_directory</span><span class=p>(</span><span class=n>current</span><span class=p>)</span>
                    <span class=c1># add the current directory name</span>
                    <span class=k>if</span> <span class=n>log_progress</span><span class=p>:</span>
                        <span class=bp>self</span><span class=o>.</span><span class=n>_progress_logger</span><span class=p>(</span>
                            <span class=sa>f</span><span class=s2>"entering directory </span><span class=si>{</span><span class=n>current</span><span class=si>!r}</span><span class=s2>."</span><span class=p>)</span>
                    <span class=k>yield from</span> <span class=bp>self</span><span class=o>.</span><span class=n>__internal_parse</span><span class=p>(</span><span class=n>current</span><span class=o>.</span><span class=n>list_dir</span><span class=p>(</span>
                        <span class=n>list_files</span><span class=p>,</span> <span class=n>list_dirs</span><span class=p>),</span> <span class=n>log_progress</span><span class=p>,</span> <span class=kc>False</span><span class=p>)</span>
                    <span class=bp>self</span><span class=o>.</span><span class=n>_end_list_directory</span><span class=p>(</span><span class=n>current</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>is_root</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_end_parse</span><span class=p>(</span><span class=n>current</span><span class=p>)</span>
            <span class=k>if</span> <span class=n>log_progress</span><span class=p>:</span>
                <span class=bp>self</span><span class=o>.</span><span class=n>_progress_logger</span><span class=p>(</span><span class=sa>f</span><span class=s2>"finished parsing </span><span class=si>{</span><span class=n>current</span><span class=si>!r}</span><span class=s2>."</span><span class=p>)</span>

<div class=viewcode-block id=Parser.parse>
<a class=viewcode-back href=../../../pycommons.io.html#pycommons.io.parser.Parser.parse>[docs]</a>
    <span class=k>def</span><span class=w> </span><span class=nf>parse</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>path</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>log_progress</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>True</span><span class=p>)</span> \
            <span class=o>-></span> <span class=n>Generator</span><span class=p>[</span><span class=n>T</span><span class=p>,</span> <span class=kc>None</span><span class=p>,</span> <span class=kc>None</span><span class=p>]:</span>
<span class=w>        </span><span class=sd>"""</span>
<span class=sd>        Parse the given path.</span>

<span class=sd>        :param path: the path to parse</span>
<span class=sd>        :param log_progress: should the progress be logged?</span>
<span class=sd>        :returns: the parsed sequence</span>
<span class=sd>        """</span>
        <span class=n>root</span><span class=p>:</span> <span class=n>Final</span><span class=p>[</span><span class=n>Path</span><span class=p>]</span> <span class=o>=</span> <span class=n>Path</span><span class=p>(</span><span class=n>path</span><span class=p>)</span>
        <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>log_progress</span><span class=p>,</span> <span class=nb>bool</span><span class=p>):</span>
            <span class=k>raise</span> <span class=n>type_error</span><span class=p>(</span><span class=n>log_progress</span><span class=p>,</span> <span class=s2>"log_progress"</span><span class=p>,</span> <span class=nb>bool</span><span class=p>)</span>

        <span class=k>if</span> <span class=n>log_progress</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_progress_logger</span><span class=p>(</span><span class=sa>f</span><span class=s2>"beginning to parse </span><span class=si>{</span><span class=n>root</span><span class=si>!r}</span><span class=s2>."</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_start_parse</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>__internal_parse</span><span class=p>((</span><span class=n>root</span><span class=p>,</span> <span class=p>),</span> <span class=n>log_progress</span><span class=p>,</span> <span class=kc>True</span><span class=p>)</span></div>


<div class=viewcode-block id=Parser.parse_file>
<a class=viewcode-back href=../../../pycommons.io.html#pycommons.io.parser.Parser.parse_file>[docs]</a>
    <span class=k>def</span><span class=w> </span><span class=nf>parse_file</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>file</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>log_progress</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>)</span> <span class=o>-></span> <span class=n>T</span><span class=p>:</span>
<span class=w>        </span><span class=sd>"""</span>
<span class=sd>        Parse a single file.</span>

<span class=sd>        This method guarantees to not return `None`. If the internal parsing</span>
<span class=sd>        process yields `None` anyway, it will raise a :class:`TypeError`.</span>
<span class=sd>        It will also raise a :class:`ValueError` if `file` does not identify a</span>
<span class=sd>        file.</span>

<span class=sd>        :param file: the file to parse</span>
<span class=sd>        :param log_progress: should the progress be logged?</span>
<span class=sd>        :returns: the parsing result.</span>
<span class=sd>        """</span>
        <span class=n>path</span><span class=p>:</span> <span class=n>Final</span><span class=p>[</span><span class=n>Path</span><span class=p>]</span> <span class=o>=</span> <span class=n>file_path</span><span class=p>(</span><span class=n>file</span><span class=p>)</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=k>return</span> <span class=nb>next</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>parse</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=n>log_progress</span><span class=p>))</span>
        <span class=k>except</span> <span class=ne>StopIteration</span> <span class=k>as</span> <span class=n>se</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span>
                <span class=sa>f</span><span class=s2>"result of parsing file </span><span class=si>{</span><span class=n>path</span><span class=si>!r}</span><span class=s2> should not be None."</span><span class=p>)</span>\
                <span class=kn>from</span><span class=w> </span><span class=nn>se</span></div>


<div class=viewcode-block id=Parser.parse_directory>
<a class=viewcode-back href=../../../pycommons.io.html#pycommons.io.parser.Parser.parse_directory>[docs]</a>
    <span class=k>def</span><span class=w> </span><span class=nf>parse_directory</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>directory</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>log_progress</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>True</span><span class=p>)</span> \
            <span class=o>-></span> <span class=n>Generator</span><span class=p>[</span><span class=n>T</span><span class=p>,</span> <span class=kc>None</span><span class=p>,</span> <span class=kc>None</span><span class=p>]:</span>
<span class=w>        </span><span class=sd>"""</span>
<span class=sd>        Parse a directory of files.</span>

<span class=sd>        This function basically works exactly as</span>
<span class=sd>        :meth:`~pycommons.io.parser.Parser.parse`, but it enforces that</span>
<span class=sd>        `directory` is a directory and raises a :class:`ValueError` otherwise.</span>

<span class=sd>        :param directory: the directory to parse</span>
<span class=sd>        :param log_progress: should the progress be logged?</span>
<span class=sd>        :returns: the generator with the parsing results</span>
<span class=sd>        """</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>parse</span><span class=p>(</span><span class=n>directory_path</span><span class=p>(</span><span class=n>directory</span><span class=p>),</span> <span class=n>log_progress</span><span class=p>)</span></div>
</div>

</pre></div><div class=clearer></div></div></div></div><div aria-label=Main class=sphinxsidebar role=navigation><div class=sphinxsidebarwrapper><search id=searchbox role=search style=display:none> <h3 id=searchlabel>Quick search</h3> <div class=searchformwrapper><form action=../../../search.html class=search><input aria-labelledby=searchlabel autocapitalize=off autocomplete=off autocorrect=off name=q spellcheck=false><input type=submit value=Go></form></div> </search><script>document.getElementById(`searchbox`).style.display=`block`;</script></div></div><div class=clearer></div></div><div aria-label=Related class=related role=navigation><h3>Navigation</h3><ul><li class=right style=margin-right:10px><a title="General Index"href=../../../genindex.html>index</a><li class=right><a title="Python Module Index"href=../../../py-modindex.html>modules</a> |<li class="nav-item nav-item-0"><a href=../../../index.html>pycommons 0.8.89 documentation</a> »<li class="nav-item nav-item-1"><a href=../../index.html>Module code</a> »<li class="nav-item nav-item-this"><a href>pycommons.io.parser</a></ul></div><div class=footer role=contentinfo>© Copyright 2023-2026, Thomas Weise.</div>
