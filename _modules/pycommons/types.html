<!doctype html><html data-content_root=../../ lang=en><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0"name=viewport><title>pycommons.types — pycommons 0.8.89 documentation</title><link href="../../_static/pygments.css?v=b86133f3"rel=stylesheet><link href="../../_static/bizstyle.css?v=5283bb3d"rel=stylesheet><script src="../../_static/documentation_options.js?v=4db5eb0a"></script><script src="../../_static/doctools.js?v=fd6eb6e6"></script><script src="../../_static/sphinx_highlight.js?v=6ffebe34"></script><script src=../../_static/bizstyle.js></script><link href=https://thomasweise.github.io/pycommons/_modules/pycommons/types.html rel=canonical><link href=../../genindex.html rel=index title=Index><link href=../../search.html rel=search title=Search><meta content="width=device-width,initial-scale=1.0"name=viewport><body><div aria-label=Related class=related role=navigation><h3>Navigation</h3><ul><li class=right style=margin-right:10px><a title="General Index"accesskey=I href=../../genindex.html>index</a><li class=right><a title="Python Module Index"href=../../py-modindex.html>modules</a> |<li class="nav-item nav-item-0"><a href=../../index.html>pycommons 0.8.89 documentation</a> »<li class="nav-item nav-item-1"><a accesskey=U href=../index.html>Module code</a> »<li class="nav-item nav-item-this"><a href>pycommons.types</a></ul></div><div class=document><div class=documentwrapper><div class=bodywrapper><div class=body role=main><h1>Source code for pycommons.types</h1><div class=highlight><pre>
<span></span><span class=sd>"""Some basic type handling routines."""</span>
<span class=kn>from</span><span class=w> </span><span class=nn>typing</span><span class=w> </span><span class=kn>import</span> <span class=n>Any</span><span class=p>,</span> <span class=n>Iterable</span>


<div class=viewcode-block id=type_name>
<a class=viewcode-back href=../../pycommons.html#pycommons.types.type_name>[docs]</a>
<span class=k>def</span><span class=w> </span><span class=nf>type_name</span><span class=p>(</span><span class=n>tpe</span><span class=p>:</span> <span class=nb>type</span> <span class=o>|</span> <span class=kc>None</span><span class=p>)</span> <span class=o>-></span> <span class=nb>str</span><span class=p>:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Convert a type to a string which represents its name.</span>

<span class=sd>    :param tpe: the type</span>
<span class=sd>    :returns: the string</span>

<span class=sd>    >>> type_name(None)</span>
<span class=sd>    'None'</span>
<span class=sd>    >>> type_name(type(None))</span>
<span class=sd>    'None'</span>
<span class=sd>    >>> type_name(int)</span>
<span class=sd>    'int'</span>
<span class=sd>    >>> from pycommons.io.path import file_path, Path</span>
<span class=sd>    >>> type_name(Path)</span>
<span class=sd>    'pycommons.io.path.Path'</span>
<span class=sd>    >>> from typing import Callable</span>
<span class=sd>    >>> type_name(Callable)</span>
<span class=sd>    'typing.Callable'</span>
<span class=sd>    >>> from typing import Callable as Ca</span>
<span class=sd>    >>> type_name(Ca)</span>
<span class=sd>    'typing.Callable'</span>
<span class=sd>    >>> from typing import Callable as Aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span>
<span class=sd>    >>> type_name(Aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)</span>
<span class=sd>    'typing.Callable'</span>
<span class=sd>    >>> import typing as ttttttttttttttttttttttttttttttttttttttttttt</span>
<span class=sd>    >>> type_name(ttttttttttttttttttttttttttttttttttttttttttt.Callable)</span>
<span class=sd>    'typing.Callable'</span>
<span class=sd>    """</span>
    <span class=k>if</span> <span class=n>tpe</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=k>return</span> <span class=s2>"None"</span>
    <span class=n>c1</span><span class=p>:</span> <span class=nb>str</span> <span class=o>=</span> <span class=nb>str</span><span class=p>(</span><span class=n>tpe</span><span class=p>)</span>
    <span class=k>if</span> <span class=n>c1</span><span class=o>.</span><span class=n>startswith</span><span class=p>(</span><span class=s2>"&LTclass '"</span><span class=p>):</span>
        <span class=n>c1</span> <span class=o>=</span> <span class=n>c1</span><span class=p>[</span><span class=mi>8</span><span class=p>:</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span>
    <span class=k>if</span> <span class=n>c1</span> <span class=o>==</span> <span class=s2>"NoneType"</span><span class=p>:</span>
        <span class=k>return</span> <span class=s2>"None"</span>
    <span class=k>if</span> <span class=nb>hasattr</span><span class=p>(</span><span class=n>tpe</span><span class=p>,</span> <span class=s2>"__qualname__"</span><span class=p>):</span>
        <span class=n>c2</span><span class=p>:</span> <span class=nb>str</span> <span class=o>=</span> <span class=n>tpe</span><span class=o>.</span><span class=vm>__qualname__</span>
        <span class=k>if</span> <span class=nb>hasattr</span><span class=p>(</span><span class=n>tpe</span><span class=p>,</span> <span class=s2>"__module__"</span><span class=p>):</span>
            <span class=n>module</span> <span class=o>=</span> <span class=n>tpe</span><span class=o>.</span><span class=vm>__module__</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>module</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>)</span> <span class=ow>and</span> <span class=p>(</span><span class=n>module</span> <span class=o>!=</span> <span class=s2>"builtins"</span><span class=p>):</span>
                <span class=n>c2</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>module</span><span class=si>}</span><span class=s2>.</span><span class=si>{</span><span class=n>c2</span><span class=si>}</span><span class=s2>"</span>
        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>c2</span><span class=p>)</span> <span class=o>>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>c1</span><span class=p>):</span>
            <span class=k>return</span> <span class=n>c2</span>
    <span class=k>return</span> <span class=n>c1</span>  <span class=c1># will probably never happen</span></div>



<div class=viewcode-block id=type_name_of>
<a class=viewcode-back href=../../pycommons.html#pycommons.types.type_name_of>[docs]</a>
<span class=k>def</span><span class=w> </span><span class=nf>type_name_of</span><span class=p>(</span><span class=n>obj</span><span class=p>:</span> <span class=n>Any</span><span class=p>)</span> <span class=o>-></span> <span class=nb>str</span><span class=p>:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Get the fully-qualified class name of an object.</span>

<span class=sd>    :param obj: the object</span>
<span class=sd>    :returns: the fully-qualified class name of the object</span>

<span class=sd>    >>> from pycommons.io.path import Path, file_path</span>
<span class=sd>    >>> type_name_of(Path)</span>
<span class=sd>    'type'</span>
<span class=sd>    >>> type_name_of(file_path(__file__))</span>
<span class=sd>    'pycommons.io.path.Path'</span>
<span class=sd>    >>> type_name_of(None)</span>
<span class=sd>    'None'</span>
<span class=sd>    >>> type_name_of(int)</span>
<span class=sd>    'type'</span>
<span class=sd>    >>> type_name_of(print)</span>
<span class=sd>    'builtin_function_or_method'</span>
<span class=sd>    >>> from typing import Callable</span>
<span class=sd>    >>> type_name_of(Callable)</span>
<span class=sd>    'typing._CallableType'</span>
<span class=sd>    >>> from math import sin</span>
<span class=sd>    >>> type_name_of(sin)</span>
<span class=sd>    'builtin_function_or_method'</span>
<span class=sd>    >>> import pycommons.io as iox</span>
<span class=sd>    >>> type_name_of(iox)</span>
<span class=sd>    'module'</span>
<span class=sd>    """</span>
    <span class=k>if</span> <span class=n>obj</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=k>return</span> <span class=s2>"None"</span>
    <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=nb>type</span><span class=p>):</span>
        <span class=k>return</span> <span class=s2>"type"</span>
    <span class=k>return</span> <span class=n>type_name</span><span class=p>(</span><span class=nb>type</span><span class=p>(</span><span class=n>obj</span><span class=p>))</span></div>



<div class=viewcode-block id=type_error>
<a class=viewcode-back href=../../pycommons.html#pycommons.types.type_error>[docs]</a>
<span class=k>def</span><span class=w> </span><span class=nf>type_error</span><span class=p>(</span><span class=n>obj</span><span class=p>:</span> <span class=n>Any</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
               <span class=n>expected</span><span class=p>:</span> <span class=nb>type</span> <span class=o>|</span> <span class=n>Iterable</span><span class=p>[</span><span class=nb>type</span><span class=p>]</span> <span class=o>|</span> <span class=kc>None</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
               <span class=n>call</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>)</span> <span class=o>-></span> <span class=ne>ValueError</span> <span class=o>|</span> <span class=ne>TypeError</span><span class=p>:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Create an error to raise if a type did not fit.</span>

<span class=sd>    This eror contains information about the object name, the expected type,</span>
<span class=sd>    the actual type, and, in some cases, the actual value of the object. This</span>
<span class=sd>    should help tracing down what went wrong.</span>

<span class=sd>    We *sometimes* include the actual value of the object. This happens if</span>
<span class=sd>    the object is an `int`, `float`, or `bool`. If the object is a `str`, then</span>
<span class=sd>    we include at most the first 32 characters. If the ojbect is a `list`,</span>
<span class=sd>    `tuple`, `set`, `dict`, or `frozenset`, then we include its length.</span>

<span class=sd>    In previous versions of this function, we always included the full</span>
<span class=sd>    representation of the object. However, this might lead to very lengthy</span>
<span class=sd>    output and could even cause an out-of-memory exception. So we now focus on</span>
<span class=sd>    the above classes only.</span>

<span class=sd>    Since one might still try to cause some mischief by overriding the</span>
<span class=sd>    `__str__` or `__len__` methods of these objects, we force that the methods</span>
<span class=sd>    of the base classes are used, which looks a bit odd in the code but should</span>
<span class=sd>    at least somewhat help preventing issues.</span>

<span class=sd>    :param obj: the object that is of the wrong type</span>
<span class=sd>    :param name: the name of the object</span>
<span class=sd>    :param expected: the expected types (or `None`)</span>
<span class=sd>    :param call: the object should have been callable?</span>
<span class=sd>    :returns: a :class:`TypeError` with a descriptive information</span>

<span class=sd>    >>> type_error(1.3, "var", int)</span>
<span class=sd>    TypeError('var should be an instance of int but is float, namely 1.3.')</span>
<span class=sd>    >>> type_error("x", "z", (int, float)).args[0]</span>
<span class=sd>    "z should be an instance of any in {float, int} but is str, namely 'x'."</span>
<span class=sd>    >>> type_error("x", "z", (int, float, None)).args[0]</span>
<span class=sd>    "z should be an instance of any in {None, float, int} but is str, namely \</span>
<span class=sd>'x'."</span>
<span class=sd>    >>> type_error("x", "z", (int, float, type(None))).args[0]</span>
<span class=sd>    "z should be an instance of any in {None, float, int} but is str, namely \</span>
<span class=sd>'x'."</span>
<span class=sd>    >>> type_error("f", "q", call=True).args[0]</span>
<span class=sd>    "q should be a callable but is str, namely 'f'."</span>
<span class=sd>    >>> type_error("1", "2", bool, call=True).args[0]</span>
<span class=sd>    "2 should be an instance of bool or a callable but is str, namely '1'."</span>
<span class=sd>    >>> type_error(None, "x", str)</span>
<span class=sd>    TypeError('x should be an instance of str but is None.')</span>
<span class=sd>    >>> type_error("123456789012345678901234567890123456789", "var", int)</span>
<span class=sd>    TypeError("var should be an instance of int but is str, namely \</span>
<span class=sd>'123456789012345678901234567890...'.")</span>
<span class=sd>    >>> type_error("12345678901234567890123456789012", "var", int)</span>
<span class=sd>    TypeError("var should be an instance of int but is str, namely \</span>
<span class=sd>'12345678901234567890123456789012'.")</span>
<span class=sd>    >>> type_error("123456789012345678901234567890123", "var", int)</span>
<span class=sd>    TypeError("var should be an instance of int but is str, namely \</span>
<span class=sd>'12345678901234567890123456789...'.")</span>
<span class=sd>    >>> type_error([1], "var", int)</span>
<span class=sd>    TypeError('var should be an instance of int but is list of length 1.')</span>
<span class=sd>    >>> type_error({2, 3}, "var", int)</span>
<span class=sd>    TypeError('var should be an instance of int but is set of length 2.')</span>
<span class=sd>    >>> type_error((1, 2, 3), "var", int)</span>
<span class=sd>    TypeError('var should be an instance of int but is tuple of length 3.')</span>
<span class=sd>    >>> type_error({}, "var", int)</span>
<span class=sd>    TypeError('var should be an instance of int but is dict of length 0.')</span>
<span class=sd>    >>> type_error(frozenset((23, )), "var", int)</span>
<span class=sd>    TypeError('var should be an instance of int but is frozenset of \</span>
<span class=sd>length 1.')</span>
<span class=sd>    >>> type_error(1, "var", list)</span>
<span class=sd>    TypeError('var should be an instance of list but is int, namely 1.')</span>
<span class=sd>    >>> type_error(1.3, "var", list)</span>
<span class=sd>    TypeError('var should be an instance of list but is float, namely 1.3.')</span>
<span class=sd>    >>> type_error(True, "var", list)</span>
<span class=sd>    TypeError('var should be an instance of list but is bool, namely True.')</span>
<span class=sd>    >>> type_error(ValueError("x"), "var", list)</span>
<span class=sd>    TypeError('var should be an instance of list but is ValueError.')</span>
<span class=sd>    >>> type_error(None, "var", list)</span>
<span class=sd>    TypeError('var should be an instance of list but is None.')</span>
<span class=sd>    """</span>
    <span class=n>exp</span><span class=p>:</span> <span class=nb>str</span> <span class=o>=</span> <span class=s2>""</span>
    <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>expected</span><span class=p>,</span> <span class=n>Iterable</span><span class=p>):</span>
        <span class=n>exp</span> <span class=o>=</span> <span class=s2>", "</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=nb>sorted</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=n>type_name</span><span class=p>,</span> <span class=n>expected</span><span class=p>)))</span>
        <span class=n>exp</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>"an instance of any in </span><span class=se>{{</span><span class=si>{</span><span class=n>exp</span><span class=si>}</span><span class=se>}}</span><span class=s2>"</span>
    <span class=k>elif</span> <span class=n>expected</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>exp</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>"an instance of </span><span class=si>{</span><span class=n>type_name</span><span class=p>(</span><span class=n>expected</span><span class=p>)</span><span class=si>}</span><span class=s2>"</span>
    <span class=k>if</span> <span class=n>call</span><span class=p>:</span>
        <span class=n>exp</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>exp</span><span class=si>}</span><span class=s2> or a callable"</span> <span class=k>if</span> <span class=n>exp</span> <span class=k>else</span> <span class=s2>"a callable"</span>

    <span class=n>message</span><span class=p>:</span> <span class=nb>str</span>
    <span class=k>if</span> <span class=n>obj</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>message</span> <span class=o>=</span> <span class=s2>"None"</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>message</span> <span class=o>=</span> <span class=n>type_name_of</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span>
        <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=nb>bool</span><span class=p>):</span>
            <span class=n>message</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>message</span><span class=si>}</span><span class=s2>, namely </span><span class=si>{</span><span class=nb>bool</span><span class=o>.</span><span class=fm>__str__</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span><span class=si>}</span><span class=s2>"</span>
        <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=nb>int</span><span class=p>):</span>
            <span class=n>message</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>message</span><span class=si>}</span><span class=s2>, namely </span><span class=si>{</span><span class=nb>int</span><span class=o>.</span><span class=fm>__str__</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span><span class=si>}</span><span class=s2>"</span>
        <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=nb>float</span><span class=p>):</span>
            <span class=n>message</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>message</span><span class=si>}</span><span class=s2>, namely </span><span class=si>{</span><span class=nb>float</span><span class=o>.</span><span class=fm>__str__</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span><span class=si>}</span><span class=s2>"</span>
        <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=nb>str</span><span class=p>):</span>
            <span class=n>strlen</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=nb>str</span><span class=o>.</span><span class=fm>__len__</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span>
            <span class=k>if</span> <span class=n>strlen</span> <span class=o>></span> <span class=mi>32</span><span class=p>:</span>  <span class=c1># take care of strings that are too long</span>
                <span class=n>obj</span> <span class=o>=</span> <span class=nb>str</span><span class=o>.</span><span class=fm>__getitem__</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=nb>slice</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>30</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span> <span class=o>+</span> <span class=s2>"..."</span>
            <span class=n>message</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>message</span><span class=si>}</span><span class=s2>, namely </span><span class=si>{</span><span class=nb>str</span><span class=o>.</span><span class=fm>__str__</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span><span class=si>!r}</span><span class=s2>"</span>
        <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=nb>list</span><span class=p>):</span>
            <span class=n>message</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>message</span><span class=si>}</span><span class=s2> of length </span><span class=si>{</span><span class=nb>list</span><span class=o>.</span><span class=fm>__len__</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span><span class=si>}</span><span class=s2>"</span>
        <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=nb>tuple</span><span class=p>):</span>
            <span class=n>message</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>message</span><span class=si>}</span><span class=s2> of length </span><span class=si>{</span><span class=nb>tuple</span><span class=o>.</span><span class=fm>__len__</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span><span class=si>}</span><span class=s2>"</span>
        <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=nb>set</span><span class=p>):</span>
            <span class=n>message</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>message</span><span class=si>}</span><span class=s2> of length </span><span class=si>{</span><span class=nb>set</span><span class=o>.</span><span class=fm>__len__</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span><span class=si>}</span><span class=s2>"</span>
        <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=nb>dict</span><span class=p>):</span>
            <span class=n>message</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>message</span><span class=si>}</span><span class=s2> of length </span><span class=si>{</span><span class=nb>dict</span><span class=o>.</span><span class=fm>__len__</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span><span class=si>}</span><span class=s2>"</span>
        <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=nb>frozenset</span><span class=p>):</span>
            <span class=n>message</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>message</span><span class=si>}</span><span class=s2> of length </span><span class=si>{</span><span class=nb>frozenset</span><span class=o>.</span><span class=fm>__len__</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span><span class=si>}</span><span class=s2>"</span>
    <span class=n>message</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>name</span><span class=si>}</span><span class=s2> should be </span><span class=si>{</span><span class=n>exp</span><span class=si>}</span><span class=s2> but is </span><span class=si>{</span><span class=n>message</span><span class=si>}</span><span class=s2>."</span>

    <span class=k>return</span> <span class=ne>TypeError</span><span class=p>(</span><span class=n>message</span><span class=p>)</span></div>



<div class=viewcode-block id=check_int_range>
<a class=viewcode-back href=../../pycommons.html#pycommons.types.check_int_range>[docs]</a>
<span class=k>def</span><span class=w> </span><span class=nf>check_int_range</span><span class=p>(</span><span class=n>val</span><span class=p>:</span> <span class=n>Any</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=nb>str</span> <span class=o>|</span> <span class=kc>None</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
                    <span class=n>min_value</span><span class=p>:</span> <span class=nb>int</span> <span class=o>|</span> <span class=nb>float</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
                    <span class=n>max_value</span><span class=p>:</span> <span class=nb>int</span> <span class=o>|</span> <span class=nb>float</span> <span class=o>=</span> <span class=mi>1_000_000_000</span><span class=p>)</span> <span class=o>-></span> <span class=nb>int</span><span class=p>:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Check whether a value `val` is an integer in a given range.</span>

<span class=sd>    Via type annotation, this method actually accepts a value `val` of any</span>
<span class=sd>    type as input. However, if `val` is not an instance of `int`, it will</span>
<span class=sd>    throw an error. Also, if `val` is not in the prescribed range, it will</span>
<span class=sd>    throw an error, too. By default, the range is `0...1_000_000_000`.</span>

<span class=sd>    I noticed that often, we think that  only want to check a lower limit</span>
<span class=sd>    for `val`, e.g., that a number of threads or a population size should be</span>
<span class=sd>    `val > 0`. However, in such cases, there also always a reasonable upper</span>
<span class=sd>    limits. We never actually want an EA to have a population larger than,</span>
<span class=sd>    say, 1_000_000_000. That would make no sense. So indeed, whenever we have</span>
<span class=sd>    a lower limit for a parameter, we also should have an upper limit</span>
<span class=sd>    resulting from physical constraints. 1_000_000_000 is a reasonably sane</span>
<span class=sd>    upper limit in many situations. If we need smaller or larger limits, we</span>
<span class=sd>    can of course specify them.</span>

<span class=sd>    Notice that there is one strange border case: In Python, `bool` is a</span>
<span class=sd>    subtype of `int`, where `True` has value `1` and `False` has value `0`.</span>
<span class=sd>    See &LThttps://docs.python.org/3/library/functions.html#bool>.</span>
<span class=sd>    We therefore treat `bool` values indeed as instances of `int`.</span>

<span class=sd>    :param val: the value to check</span>
<span class=sd>    :param name: the name of the value, or `None`</span>
<span class=sd>    :param min_value: the minimum permitted value</span>
<span class=sd>    :param max_value: the maximum permitted value</span>
<span class=sd>    :returns: `val` if everything is OK</span>
<span class=sd>    :raises TypeError: if `val` is not an `int`</span>
<span class=sd>    :raises ValueError: if `val` is an `int` but outside the prescribed range</span>

<span class=sd>    >>> try:</span>
<span class=sd>    ...   print(check_int_range(12, min_value=7, max_value=13))</span>
<span class=sd>    ... except (ValueError, TypeError) as err:</span>
<span class=sd>    ...   print(err)</span>
<span class=sd>    12</span>

<span class=sd>    >>> try:</span>
<span class=sd>    ...   print(check_int_range(123, min_value=7, max_value=13))</span>
<span class=sd>    ... except (ValueError, TypeError) as err:</span>
<span class=sd>    ...   print(err)</span>
<span class=sd>    ...   print(err.__class__)</span>
<span class=sd>    Value=123 is invalid, must be in 7..13.</span>
<span class=sd>    &LTclass 'ValueError'></span>

<span class=sd>    >>> try:</span>
<span class=sd>    ...   print(check_int_range(5.0, name="ThisIsFloat"))</span>
<span class=sd>    ... except (ValueError, TypeError) as err:</span>
<span class=sd>    ...   print(err)</span>
<span class=sd>    ...   print(err.__class__)</span>
<span class=sd>    ThisIsFloat should be an instance of int but is float, namely 5.0.</span>
<span class=sd>    &LTclass 'TypeError'></span>

<span class=sd>    The behavior in the border case of `bool` instances actually also being</span>
<span class=sd>    instances of `int`:</span>

<span class=sd>    >>> check_int_range(True, "true", 0, 2)</span>
<span class=sd>    True</span>

<span class=sd>    >>> check_int_range(False, "false", 0, 2)</span>
<span class=sd>    False</span>

<span class=sd>    >>> try:</span>
<span class=sd>    ...   print(check_int_range(True, min_value=7, max_value=13))</span>
<span class=sd>    ... except (ValueError, TypeError) as err:</span>
<span class=sd>    ...   print(err)</span>
<span class=sd>    ...   print(err.__class__)</span>
<span class=sd>    Value=True is invalid, must be in 7..13.</span>
<span class=sd>    &LTclass 'ValueError'></span>
<span class=sd>    """</span>
    <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>val</span><span class=p>,</span> <span class=nb>int</span><span class=p>):</span>
        <span class=k>raise</span> <span class=n>type_error</span><span class=p>(</span><span class=n>val</span><span class=p>,</span> <span class=s2>"value"</span> <span class=k>if</span> <span class=n>name</span> <span class=ow>is</span> <span class=kc>None</span> <span class=k>else</span> <span class=n>name</span><span class=p>,</span> <span class=nb>int</span><span class=p>)</span>
    <span class=k>if</span> <span class=n>min_value</span> <span class=o><=</span> <span class=n>val</span> <span class=o><=</span> <span class=n>max_value</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>val</span>
    <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=s1>'Value'</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=ow>is</span><span class=w> </span><span class=kc>None</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=n>name</span><span class=si>}</span><span class=s2>=</span><span class=si>{</span><span class=n>val</span><span class=si>!r}</span><span class=s2> is "</span>
                     <span class=sa>f</span><span class=s2>"invalid, must be in </span><span class=si>{</span><span class=n>min_value</span><span class=si>}</span><span class=s2>..</span><span class=si>{</span><span class=n>max_value</span><span class=si>}</span><span class=s2>."</span><span class=p>)</span></div>



<div class=viewcode-block id=check_to_int_range>
<a class=viewcode-back href=../../pycommons.html#pycommons.types.check_to_int_range>[docs]</a>
<span class=k>def</span><span class=w> </span><span class=nf>check_to_int_range</span><span class=p>(</span><span class=n>val</span><span class=p>:</span> <span class=n>Any</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=nb>str</span> <span class=o>|</span> <span class=kc>None</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
                       <span class=n>min_value</span><span class=p>:</span> <span class=nb>int</span> <span class=o>|</span> <span class=nb>float</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
                       <span class=n>max_value</span><span class=p>:</span> <span class=nb>int</span> <span class=o>|</span> <span class=nb>float</span> <span class=o>=</span> <span class=mi>1_000_000_000</span><span class=p>)</span> <span class=o>-></span> <span class=nb>int</span><span class=p>:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Check whether a value `val` can be converted an integer in a given range.</span>

<span class=sd>    :param val: the value to convert via `int(...)` and then to check</span>
<span class=sd>    :param name: the name of the value, or `None`</span>
<span class=sd>    :param min_value: the minimum permitted value</span>
<span class=sd>    :param max_value: the maximum permitted value</span>
<span class=sd>    :returns: `val` if everything is OK</span>
<span class=sd>    :raises TypeError: if `val` is `None`</span>
<span class=sd>    :raises ValueError: if `val` is not `None` but can either not be converted</span>
<span class=sd>       to an `int` or to an `int` outside the prescribed range</span>

<span class=sd>    >>> try:</span>
<span class=sd>    ...   print(check_to_int_range(12))</span>
<span class=sd>    ... except (ValueError, TypeError) as err:</span>
<span class=sd>    ...   print(err)</span>
<span class=sd>    12</span>

<span class=sd>    >>> try:</span>
<span class=sd>    ...   print(check_to_int_range(12.0))</span>
<span class=sd>    ... except (ValueError, TypeError) as err:</span>
<span class=sd>    ...   print(err)</span>
<span class=sd>    12</span>

<span class=sd>    >>> try:</span>
<span class=sd>    ...   print(check_to_int_range("12"))</span>
<span class=sd>    ... except (ValueError, TypeError) as err:</span>
<span class=sd>    ...   print(err)</span>
<span class=sd>    12</span>

<span class=sd>    >>> try:</span>
<span class=sd>    ...   print(check_to_int_range("A"))</span>
<span class=sd>    ... except (ValueError, TypeError) as err:</span>
<span class=sd>    ...   print(err)</span>
<span class=sd>    ...   print(err.__class__)</span>
<span class=sd>    Cannot convert value='A' to int, let alone in range 0..1000000000.</span>
<span class=sd>    &LTclass 'ValueError'></span>

<span class=sd>    >>> try:</span>
<span class=sd>    ...   print(check_to_int_range(None))</span>
<span class=sd>    ... except (ValueError, TypeError) as err:</span>
<span class=sd>    ...   print(err)</span>
<span class=sd>    ...   print(err.__class__)</span>
<span class=sd>    Cannot convert value=None to int, let alone in range 0..1000000000.</span>
<span class=sd>    &LTclass 'TypeError'></span>
<span class=sd>    """</span>
    <span class=k>try</span><span class=p>:</span>
        <span class=n>conv</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>val</span><span class=p>)</span>
    <span class=k>except</span> <span class=p>(</span><span class=ne>ValueError</span><span class=p>,</span> <span class=ne>TypeError</span><span class=p>)</span> <span class=k>as</span> <span class=n>errx</span><span class=p>:</span>
        <span class=k>raise</span> <span class=p>(</span><span class=ne>ValueError</span> <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>errx</span><span class=p>,</span> <span class=ne>ValueError</span><span class=p>)</span> <span class=k>else</span> <span class=ne>TypeError</span><span class=p>)(</span>
            <span class=sa>f</span><span class=s2>"Cannot convert </span><span class=si>{</span><span class=s1>'value'</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=ow>is</span><span class=w> </span><span class=kc>None</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=n>name</span><span class=si>}</span><span class=s2>=</span><span class=si>{</span><span class=n>val</span><span class=si>!r}</span><span class=s2> "</span>
            <span class=sa>f</span><span class=s2>"to int, let alone in range </span><span class=si>{</span><span class=n>min_value</span><span class=si>}</span><span class=s2>..</span><span class=si>{</span><span class=n>max_value</span><span class=si>}</span><span class=s2>."</span><span class=p>)</span> <span class=kn>from</span><span class=w> </span><span class=nn>errx</span>
    <span class=k>return</span> <span class=n>check_int_range</span><span class=p>(</span><span class=n>conv</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>min_value</span><span class=p>,</span> <span class=n>max_value</span><span class=p>)</span></div>

</pre></div><div class=clearer></div></div></div></div><div aria-label=Main class=sphinxsidebar role=navigation><div class=sphinxsidebarwrapper><search id=searchbox role=search style=display:none> <h3 id=searchlabel>Quick search</h3> <div class=searchformwrapper><form action=../../search.html class=search><input aria-labelledby=searchlabel autocapitalize=off autocomplete=off autocorrect=off name=q spellcheck=false><input type=submit value=Go></form></div> </search><script>document.getElementById(`searchbox`).style.display=`block`;</script></div></div><div class=clearer></div></div><div aria-label=Related class=related role=navigation><h3>Navigation</h3><ul><li class=right style=margin-right:10px><a title="General Index"href=../../genindex.html>index</a><li class=right><a title="Python Module Index"href=../../py-modindex.html>modules</a> |<li class="nav-item nav-item-0"><a href=../../index.html>pycommons 0.8.89 documentation</a> »<li class="nav-item nav-item-1"><a href=../index.html>Module code</a> »<li class="nav-item nav-item-this"><a href>pycommons.types</a></ul></div><div class=footer role=contentinfo>© Copyright 2023-2026, Thomas Weise.</div>
